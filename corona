#!/bin/sh

# Author: Andrej Smatana <xsmata03@fit.vutbr.cz>

export POSIXLY_CORRECT=yes
export LC_NUMBERIC=en_US.UTF-8
export LC_ALL=C

print_help()
{
	echo -e	"Usage: corona [-h]"
	echo -e	"       corona [FILTERS] [COMMAND] [LOG [LOG2 [...]]\n"

	echo	"Commands:"
	echo	"	infected - counts total of infected"
	echo	"	merge - merges files with logs into 1 file"
	echo -e "	TODO \n" # TODO

	echo "Filters:"
	echo	"	-a DATETIME		process logs after DATETIME including the date itself (YYYY-MM-DD)"
	echo	"	-b DATETIME		process logs before DATETIME including the date itself"
	echo	"	-g GENDER		process logs of infected people of a GENDER (M - men, Z - women)"
	echo -e "	-s [WIDTH]		print data in the form of histograms (WIDTH sets width of histograms)\n"		

	echo "	-h			give this help list"
}

awk_filter()
{
  echo "id,datum,vek,pohlavi,kraj_nuts_kod,okres_lau_kod,nakaza_v_zahranici,nakaza_zeme_csu_kod,reportovano_khs"

  if [ -z "$FILTER_GENDER" ]; then
    awk -F ','  -v filter_after="$FILTER_AFTER" -v filter_before="$FILTER_BEFORE" \
                -v rgx_dt=${_regex_date} -v rgx_int=${_regex_integer} '{
      if ((NF <= 9 && NF > 1) && ($2 ~ rgx_dt || $2 == "") && $2 >= filter_after && $2 <= filter_before  && $3 ~ rgx_int) {
        print $0;}}'
  else
    awk -F ','  -v filter_after="$FILTER_AFTER" -v filter_before="$FILTER_BEFORE" \
                -v filter_gender="$FILTER_GENDER" -v rgx_dt=${_regex_date} -v rgx_int=${_regex_integer} '{
      if ((NF <= 9 && NF > 1) && ($2 ~ rgx_dt || $2 == "") && $2 >= filter_after && $2 <= filter_before && $4 == filter_gender && $3 ~ rgx_int) {print $0}}'
  fi
}

awk_invalid()
{
  if [ -z "$FILTER_GENDER" ]; then
      awk -F ','  -v filter_after="$FILTER_AFTER" -v filter_before="$FILTER_BEFORE" \
                  -v rgx_dt=${_regex_date} -v rgx_int=${_regex_integer} '{
        if (NF <= 9 && NF>1 && $2 >= filter_after && $2 <= filter_before)  {
          if (!($2 ~ rgx_dt || $2 == ""))         {print "Invalid date: " $0;}
          else if (!($3 ~ rgx_int || $2 == ""))   {print "Invalid age: " $0;}}}'
  else
       awk -F ',' -v filter_after="$FILTER_AFTER" -v filter_before="$FILTER_BEFORE" -v filter_gender="$FILTER_GENDER" \
                  -v rgx_dt=${_regex_date} -v rgx_int=${_regex_integer} '{
          if (NF <= 9 && NF>1 && $2 >= filter_after && $2 <= filter_before && $4 == filter_gender)  {
            if (!($2 ~ rgx_dt || $2 == ""))       {print "Invalid date: " $0;}
            else if (!($3 ~ rgx_int || $2 == "")) {print "Invalid age: " $0}}}'
  fi
}

awk_histogram()
{
  if [[ $S_FLAG = "default" ]]; then
    awk -F ':' -v width="$WIDTH" '{
    constant=(int($2 / width)); printf("%s: ", $1); while (constant) { printf("#"); constant--} printf("\n");}'
  elif [[ $S_FLAG =~ ^[1-9][0-9]*$ ]]; then
    awk -F ':' -v s="$S_FLAG" '
      BEGIN {max=0;}
      {      if (max<$2) {max=$2;} a[NR] = $1; value[NR] = $2;}
      END { tmp=(int(max / s));
            for (i=1; i<=NR; i++) {constant=(int(value[i] / tmp));
            printf("%s: ", a[i]);
            while (constant) { printf("#"); constant--} printf("\n");}}'
  fi
}

awk_daily() {
  awk -F ',' 'BEGIN {count=0;} NR>1 {
        if (!($2 == ""))  {a[$2]++;} else {count++;}}
        END   {for(i in a) print i ": " a[i]; if (count) {print "None: " count;}}'
}

FILTER_AFTER=""
FILTER_BEFORE="9999-12-31"
FILTER_GENDER=""

S_FLAG=""
WIDTH=""

COMMAND="off"

GZ_LOG_FILES=""
LOG_FILES=""

_regex_date='[0-9]{4}[-](0[1-9]|1[0-2])[-](0[1-9]|[1-2][0-9]|3[0-1])'
_regex_integer='^[0-9]*$'

# parsing filters
while [ $# -gt 0 ]; do
	key=$1
	shift
	case $key in
		-a|-after)
			if [ $# -lt 1 ]; then
				echo "error: Chybajuci argument k filtru -a"
				exit 1
			else
				if [ -z $FILTER_AFTER ]; then
					FILTER_AFTER=$1
					if ! [[ $FILTER_AFTER =~ ${_regex_date} ]]; then
            echo "error: Datum musi byt vo formate YYYY-MM-DDD"
            exit 1
          fi
				else
					echo "error: Filter moze byt pouzity len 1-krat."
					exit 1
				fi
			fi
			shift
			;;
		-b|-before)
			if [ $# -lt 1 ]; then
				echo "error: Chybajuci argument k filtru -b"
				exit 1
			else
				if [ "$FILTER_BEFORE" = "9999-12-31" ]; then
					FILTER_BEFORE=$1
					# https://stackoverflow.com/questions/21112707/check-if-a-string-matches-a-regex-in-bash-script
          # TODO what about february?
					if ! [[ $FILTER_BEFORE =~ ${_regex_date} ]]; then
					  echo "error: Datum musi byt vo formate YYYY-MM-DD"
					  exit 1
					fi
				else
					echo "error: Filter moze byt pouzity len 1-krat."
					exit 1
				fi
			fi
			shift
			;;
	  -g)
	    if [ $# -lt 1 ]; then
	      echo "error: Chybajuci argument k filtru -g"
	      exit 1
	    else
	      if [ -z $FILTER_GENDER ]; then
	        FILTER_GENDER=$1
	        if ! [[ $FILTER_GENDER =~ ^[M]|[Z]$ ]]; then
	          echo "error: Parameter pohlavia moze byt len M alebo Z."
	          exit 1
	        fi
	      else
	        echo "error: Filter moze byt pouzity len 1-krat."
	        exit 1
	      fi
	    fi
	    shift
	    ;;
	  -s)
	    if ! [[ -z $S_FLAG ]]; then
	      echo "error: Filter -s moze byt pouzity len 1-krat."
        exit 1
	    else
	      if [[ $# -lt 1 ]]; then
	        S_FLAG="default"
	      else
	        if ! [[ $1 =~ ^[1-9][0-9]*$ ]]; then
	          echo "error: Parameter sirky moze byt len cele kladne cislo vacsie ako 0."
            exit 1
          fi
	        S_FLAG=$1
	      fi
	    fi
	    shift
	    ;;
	  infected|merge|gender|age|daily|monthly|yearly|countries|districts|regions)
	    if [ "$COMMAND" = "off" ]; then
	      COMMAND=$key
	    else
	      echo "error: Prikaz moze byt uvedeny len raz."
	      exit 1
	    fi
	    ;;
	  -h)
	    print_help
	    break
	    ;;
	  *.gz)
	    LOG_FILES=$( gzip -d -c $key )
	    ;;
	  *.bz2)
	    LOG_FILES=$(bzip2 -d -c $key)
	    ;;
	  *.csv)
	    LOG_FILES=$( cat $key )
	    ;;
	  *)
	    echo "error: Prikaz \"$key\" je neznamy. Precitajte si manual!\n"
	    print_help
	    exit 1
	    ;;
	esac
done

case $COMMAND in
    merge)
      cat $LOG_FILES | awk_filter
      #sed -r 's/\s+//g' $LOG_FILES | awk_invalid
      #TODO fix the bug
      COMMAND="PROCESSED"
      ;;
    off)
      echo "$LOG_FILES"  | sed -r 's/\s+//g' | awk_filter
      COMMAND="PROCESSED"
      ;;
esac

if ! [[ $COMMAND = "PROCESSED" ]]; then
  echo "$LOG_FILES"  | sed -r 's/\s+//g' | awk_filter |
    case $COMMAND in
      infected)
        sed '1d' | wc -l
        ;;
      age)
        WIDTH=10000
        awk -F ',' 'NR>1 {
          if ($3 > 105)       {a[">105  "]++;}
          else if ($3 > 95)   {a["96-105"]++;}
          else if ($3 > 85)   {a["86-95 "]++;}
          else if ($3 > 75)   {a["76-85 "]++;}
          else if ($3 > 65)   {a["66-75 "]++;}
          else if ($3 > 55)   {a["56-65 "]++;}
          else if ($3 > 45)   {a["46-55 "]++;}
          else if ($3 > 35)   {a["36-45 "]++;}
          else if ($3 > 25)   {a["26-35 "]++;}
          else if ($3 > 15)   {a["16-25 "]++;}
          else if ($3 > 5)    {a["6-15  "]++;}
          else if ($3 >= 0)   {a["0-5   "]++;}
          else                {a["None  "]++;}
          } END{for(i in a) print i ": " a[i]}' | sort -V # TODO fix the sorting bug
        ;;
      gender)
        WIDTH=100000
        awk -F ',' 'NR>1 {a[$4]++} END{for(i in a) print i ": " a[i]}'
        ;;
      daily)
        WIDTH=500
        awk_daily | sort
        ;;
      monthly)
        WIDTH=10000
        # use function awk_daily to print in format of YYYY-MM-DD and then process the output of this function
        awk_daily | awk -F '[- ]' '{
          if (!($1 == "None:")) {a[$1 "-" $2] += $4;} else {a["None"] += $2;}}
          END   {for (i in a) print i ": " a[i];}' | sort
        ;;
      yearly)
        WIDTH=100000
        awk_daily | awk -F '[- ]' '{
          ;if (!($1 == "None:")) {a[$1] += $4;} else {a["None"] += $2;}}
          END   {for (i in a) print i ": " a[i];}' | sort
        ;;
      countries)
        WIDTH=100
        awk -F ',' 'NR>1 {
          if (!($8 == "CZ" || $8 == "")) {a[$8]++;}}
          END{for (i in a) {print i ": " a[i];}}' | sort
        ;;
      districts)
        WIDTH=1000
        awk -F ',' 'BEGIN {count=0;} NR>1 {if (!($6 == "")) {a[$6]++;} else {count++;}}
                      END   {for(i in a) print i ": " a[i]; if (count) {print "None: " count;}}' | sort
        ;;
      regions)
        WIDTH=10000
        awk -F ',' 'BEGIN {count=0;} NR>1 {if (!($5 == "")) {a[$5]++;} else {count++;}}
                      END   {for(i in a) print i ": " a[i]; if (count) {print "None: " count;}}' | sort
        ;;
    esac
fi

# in the end output all invalid lines by doing the same process again
echo "$LOG_FILES"  | sed -r 's/\s+//g' | awk_invalid