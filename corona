#!/bin/sh

# Author: Andrej Smatana <xsmata03@fit.vutbr.cz>

export POSIXLY_CORRECT=yes
export LC_NUMBERIC=en_US.UTF-8
export LC_ALL=C

print_help()
{
	# echo	"Usage: corona [-h]"
	# echo	"       corona [FILTERS] [COMMAND] [LOG [LOG2 [...]]\n"
  printf "Usage: corona [-h]\n"
  printf "       corona [FILTERS] [COMMAND] [LOG [LOG2 [...]]\n"

  printf "Commands:\n"
  printf "  infected - spocita pocet nakazenych\n"
  printf "  merge - spoji nekolik souboru spolu\n"

	# echo	"Commands:"
	# echo	"	infected - counts total of infected"
	# echo	"	merge - merges files with logs into 1 file"
	# echo "	TODO \n" # TODO

	# echo "Filters:"
	# echo	"	-a DATETIME		process logs after DATETIME including the date itself (YYYY-MM-DD)"
	# echo	"	-b DATETIME		process logs before DATETIME including the date itself"
	# echo	"	-g GENDER		process logs of infected people of a GENDER (M - men, Z - women)"
	# echo "	-s [WIDTH]		print data in the form of histograms (WIDTH sets width of histograms)\n"

	# echo "	-h			give this help list"
}

awk_filter()
{
  echo "id,datum,vek,pohlavi,kraj_nuts_kod,okres_lau_kod,nakaza_v_zahranici,nakaza_zeme_csu_kod,reportovano_khs"

  awk -F ','  -v filter_after="$FILTER_AFTER" -v filter_before="$FILTER_BEFORE" \
              -v filter_gender="$FILTER_GENDER" -v rgx_dt="${_regex_date}" -v rgx_int="${_regex_integer}" '{
    if ((NF <= 9 && NF > 1) && ($2 ~ rgx_dt || $2 == "") && $2 >= filter_after && $2 <= filter_before \
      && $4 == (filter_gender ? filter_gender : $4 ) && $3 ~ rgx_int) {print $0}}'
}

awk_invalid()
{

 awk -F ',' -v filter_after="$FILTER_AFTER" -v filter_before="$FILTER_BEFORE" -v filter_gender="$FILTER_GENDER" \
            -v rgx_dt="${_regex_date}" -v rgx_int="${_regex_integer}" '{
    if (NF <= 9 && NF>1 && $2 >= filter_after && $2 <= filter_before && $4 == (filter_gender ? filter_gender : $4 ))  {
      if (!($2 ~ rgx_dt || $2 == ""))       {print "Invalid date: " $0;}
      else if (!($3 ~ rgx_int || $2 == "")) {print "Invalid age: " $0}}}'
}

awk_histogram()
{
  if [ "$S_FLAG" = "default" ]; then
    awk -F ':' -v width="$WIDTH" '{
    constant=(int($2 / width)); printf("%s: ", $1); while (constant) { printf("#"); constant--} printf("\n");}'
  else
    awk -F ':' -v s="$S_FLAG" '
      BEGIN {max=0;}
      {      if (max<$2) {max=$2;} a[NR] = $1; value[NR] = $2;}
      END { tmp=(int(max / s));
            for (i=1; i<=NR; i++) {constant=(int(value[i] / tmp));
            printf("%s: ", a[i]);
            while (constant) { printf("#"); constant--} printf("\n");}}'
  fi
}

awk_daily() {
  awk -F ',' 'BEGIN {count=0;} NR>1 {
        if (!($2 == ""))  {a[$2]++;} else {count++;}}
        END   {for(i in a) print i ": " a[i]; if (count) {print "None: " count;}}'
}

FILTER_AFTER=""
FILTER_BEFORE="9999-12-31"
FILTER_GENDER=""

S_FLAG=""
WIDTH=""

COMMAND="off"

#GZ_LOG_FILES=""
LOG_FILES=""

OUTPUT=""

_regex_date='^[0-9]{4}[-](0[1-9]|1[0-2])[-](0[1-9]|[1-2][0-9]|3[0-1])$'
_regex_integer='^[0-9]*$'

# parsing filters
while [ $# -gt 0 ]; do
	key=$1
	shift
	case $key in
		-a|--after)
			if [ $# -lt 1 ]; then
				echo "error: Chybajuci argument k filtru -a"
				exit 1
			else
				if [ -z "$FILTER_AFTER" ]; then
					FILTER_AFTER=$1
					if ! echo "$FILTER_AFTER" | grep -qE "$_regex_date"; then
            echo "error: Datum musi byt vo formate YYYY-MM-DDD"
            exit 1
          fi
				else
					echo "error: Filter -a moze byt pouzity len 1-krat."
					exit 1
				fi
			fi
			shift
			;;
		-b|--before)
			if [ $# -lt 1 ]; then
				echo "error: Chybajuci argument k filtru -b"
				exit 1
			else
				if [ "$FILTER_BEFORE" = "9999-12-31" ]; then
					FILTER_BEFORE=$1
					# https://stackoverflow.com/questions/21112707/check-if-a-string-matches-a-regex-in-bash-script
          # TODO what about february?
					if ! echo "$FILTER_BEFORE" | grep -Eq "$_regex_date"; then
					  echo "error: Datum musi byt vo formate YYYY-MM-DD"
					  exit 1
					fi
				else
					echo "error: Filter -b moze byt pouzity len 1-krat."
					exit 1
				fi
			fi
			shift
			;;
	  -g|--gender)
	    if [ $# -lt 1 ]; then
	      echo "error: Chybajuci argument k filtru -g"
	      exit 1
	    else
	      if [ -z "$FILTER_GENDER" ]; then
	        FILTER_GENDER=$1
	        if ! echo "$FILTER_GENDER" | '^[M]|[Z]$'; then
	          echo "error: Parameter pohlavia moze byt len M alebo Z."
	          exit 1
	        fi
	      else
	        echo "error: Filter moze byt pouzity len 1-krat."
	        exit 1
	      fi
	    fi
	    shift
	    ;;
	  -s)
	    if ! [ -z "$S_FLAG" ]; then # TODO: use -n instead of -z
	      echo "error: Filter -s moze byt pouzity len 1-krat."
        exit 1
	    else
	      # no need to check whether the next argument exists
	      # check just whether there's any number and then check its validity
	      if ! echo "$1" | grep -qE '^[+-]?[0-9]+([.][0-9])+?$'; then
	        S_FLAG="default"
	      else
	        if ! echo "$1"  | grep -qE '^[1-9][0-9]*$'; then
	          echo "error: Parameter sirky moze byt len cele kladne cislo vacsie ako 0."
            exit 1
          fi
	        S_FLAG=$1
	        shift
	      fi
	    fi
	    ;;
	  -h|--help)
	    print_help
	    break
	    ;;
	  infected|merge|gender|age|daily|monthly|yearly|countries|districts|regions)
	    if [ "$COMMAND" = "off" ]; then
	      COMMAND=$key
	    else
	      echo "error: Prikaz moze byt uvedeny len raz."
	      exit 1
	    fi
	    ;;
	  *.gz)
	    LOG_FILES=$( gzip -d -c "$key" )
	    ;;
	  *.bz2)
	    LOG_FILES=$( bzip2 -d -c "$key" )
	    ;;
	  *.csv)
	    LOG_FILES_2="$key $LOG_FILES" # TODO TEMPORARY 
	    ;;
	  *)
	    echo "error: Prikaz \"$key\" je neznamy. Precitajte si manual!\n"
	    print_help
	    exit 1
	    ;;
	esac
done

# TODO TEMPORARY
if [ -n "$LOG_FILES_2" ]; then
  LOG_FILES=$(cat $LOG_FILES_2)
else
  LOG_FILES=$(cat)
fi

################################ FILTERING #################################
case $COMMAND in
  infected)
    echo "$LOG_FILES" | sed -r 's/\s+//g' | awk_filter | sed '1d' | wc -l
    COMMAND="PROCESSED"
    ;;
  merge)
    #sed -r 's/\s+//g' "$LOG_FILES" | awk_filter
    cat $LOG_FILES | sed -r 's/\s+//g' | awk_filter
    COMMAND="PROCESSED"
    ;;
  off)
    echo "$LOG_FILES"  | sed -r 's/\s+//g' | awk_filter
    COMMAND="PROCESSED"
    ;;
esac

if ! [ $COMMAND = "PROCESSED" ]; then
  OUTPUT=$( echo "$LOG_FILES"  | sed -r 's/\s+//g' | awk_filter |
    case $COMMAND in
      age)
        awk -F ',' 'NR>1 {
          if ($3 > 105)       {a[">105  "]++;}
          else if ($3 > 95)   {a["96-105"]++;}
          else if ($3 > 85)   {a["86-95 "]++;}
          else if ($3 > 75)   {a["76-85 "]++;}
          else if ($3 > 65)   {a["66-75 "]++;}
          else if ($3 > 55)   {a["56-65 "]++;}
          else if ($3 > 45)   {a["46-55 "]++;}
          else if ($3 > 35)   {a["36-45 "]++;}
          else if ($3 > 25)   {a["26-35 "]++;}
          else if ($3 > 15)   {a["16-25 "]++;}
          else if ($3 > 5)    {a["6-15  "]++;}
          else if ($3 >= 0)   {a["0-5   "]++;}
          else                {a["None  "]++;}
          } END{for(i in a) print i ": " a[i]}' | sort -V |
        awk -F ':' '{if ($1 != "None  ") {print $0;} else {a = $0;}} END {print a}'
        ;;
      gender)
        awk -F ',' 'NR>1 {a[$4]++} END{for(i in a) print i ": " a[i]}'
        ;;
      daily)
        awk_daily | sort
        ;;
      monthly)
        # use function awk_daily to print in format of YYYY-MM-DD and then process the output of this function
        awk_daily | awk -F '[- ]' '{
          if (!($1 == "None:")) {a[$1 "-" $2] += $4;} else {a["None"] += $2;}}
          END   {for (i in a) print i ": " a[i];}' | sort
        ;;
      yearly)
        awk_daily | awk -F '[- ]' '{
          ;if (!($1 == "None:")) {a[$1] += $4;} else {a["None"] += $2;}}
          END   {for (i in a) print i ": " a[i];}' | sort
        ;;
      countries)
        awk -F ',' 'NR>1 {
          if (!($8 == "CZ" || $8 == "")) {a[$8]++;}}
          END{for (i in a) {print i ": " a[i];}}' | sort
        ;;
      districts)
        awk -F ',' 'BEGIN {count=0;} NR>1 {if (!($6 == "")) {a[$6]++;} else {count++;}}
                      END   {for(i in a) print i ": " a[i]; if (count) {print "None: " count;}}' | sort
        ;;
      regions)
        awk -F ',' 'BEGIN {count=0;} NR>1 {if (!($5 == "")) {a[$5]++;} else {count++;}}
                      END   {for(i in a) print i ": " a[i]; if (count) {print "None: " count;}}' | sort
        ;;
    esac
  )
  case $COMMAND in
    age)        WIDTH=10000;;
    gender)     WIDTH=100000;;
    daily)      WIDTH=500;;
    monthly)    WIDTH=10000;;
    yearly)     WIDTH=100000;;
    countries)  WIDTH=100;;
    districts)  WIDTH=1000;;
    regions)    WIDTH=10000;;
  esac

  if ! [ -z "$S_FLAG" ]; then
    echo "$OUTPUT" | awk_histogram
  else
    echo "$OUTPUT"
  fi
fi

# in the end output all invalid lines by doing the same process again
echo "$LOG_FILES" | sed -r 's/\s+//g' | awk_invalid
